//
// Project:  Aurora Module Generator version 3.1
//
//    Date:  $Date: 2009/09/08 16:23:48 $
//     Tag:  $Name: i+O-61x+189894 $
//    File:  $RCSfile: frame_check.ejava,v $
//     Rev:  $Revision: 1.3 $
//
// Company:  Xilinx
//
// (c) Copyright 2004 ? 2009 Xilinx, Inc. All rights reserved.
//
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical Applications"). 
// Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.

//

//
//  FRAME CHECK
//
//
//
//  Description: This module is a  pattern checker to test the Aurora
//               designs in hardware. The frames generated by FRAME_GEN
//               pass through the Aurora channel and arrive at the frame checker 
//               through the RX User interface. Every time an error is found in
//               the data recieved, the error count is incremented until it 
//               reaches its max value.

`timescale 1 ns / 1 ps
`define DLY #1


module aurora_FRAME_CHECK
(
    // User Interface
    RX_D,  
    RX_SRC_RDY_N,  

    // System Interface
    USER_CLK,       
    RESET,
    ERROR_COUNT
  
);

//***********************************Port Declarations*******************************

   // User Interface
    input   [0:31]     RX_D;
    input              RX_SRC_RDY_N;
    
      // System Interface
    input              USER_CLK;
    input              RESET; 
    output  [0:7]      ERROR_COUNT;
    reg     [0:7]      ERROR_COUNT;

//***************************Internal Register Declarations*************************** 

    reg     [0:31]     data_r;
    reg                data_valid_r;
    reg                error_detected_r;
    reg     [0:8]      error_count_r;
    
 
//*********************************Wire Declarations**********************************
   
    wire               data_valid_c;
    
    wire               error_detected_c;


//*********************************Main Body of Code**********************************


    


    //______________________________ Capture incoming data ___________________________    
    //Data is valid when RX_SRC_RDY_N is asserted
    assign  data_valid_c    =   !RX_SRC_RDY_N;
    


    //Capture valid incoming data, right shifted 1 bit for comparison with the next valid
    //incoming data
    always @(posedge USER_CLK)
        if(data_valid_c)    
            data_r  <=  `DLY    {RX_D[31],RX_D[0:30]};



    //Data in the data register is valid only if it was valid when captured and had no error
    always @(posedge USER_CLK)
        if(RESET)   data_valid_r    <=  `DLY    1'b0;
        else        data_valid_r    <=  `DLY    data_valid_c && !error_detected_c;



    
    //___________________________ Check incoming data for errors __________________________
         
    
    //An error is detected when valid data from the data register, when right shifted, does not match valid data
    //from the Aurora RX port
    assign  error_detected_c    =   data_valid_c && data_valid_r && (RX_D != data_r);   
    
    
    //We register the error_detected signal for use with the error counter logic
    always @(posedge USER_CLK)
        if(RESET)  
            error_detected_r    <=  `DLY    1'b0;
        else
            error_detected_r    <=  `DLY    error_detected_c;  

    
    
    //We count the total number of errors we detect. By keeping a count we make it less likely that we will miss
    //errors we did not directly observe. This counter must be reset when it reaches its max value
    always @(posedge USER_CLK)
     begin
        if(RESET)
            error_count_r       <=  `DLY    9'd0;
        else if(error_detected_r && !error_count_r[0] )
            error_count_r       <=  `DLY    error_count_r + 1;

        if(!error_count_r[0])
            assign  ERROR_COUNT =   error_count_r[1:8];
        else
             assign  ERROR_COUNT =   8'b11111111;
     end
            
    
    
    //Here we connect the lower 8 bits of the count (the MSbit is used only to check when the counter reaches
    //max value) to the module output

    
    
endmodule           
